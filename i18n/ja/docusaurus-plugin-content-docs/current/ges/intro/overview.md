---
sidebar_label: 概要

sidebar_position: 1
---

# ゲームイベントシステム

Unityのための本格的なビジュアルイベントアーキテクチャ。混沌としたイベント管理を、保守性と検証性に優れたワークフローへと変革します。

<div className="img-full-wrapper">

![Hero Diagram](/img/game-event-system/intro/overview/hero-main.png)

</div>

:::tip 開発者より
「このシステムを開発したのは、自分自身のプロジェクトで『見えないスパゲッティコード』と戦うことに疲れたからです。インディー開発者として、ビジュアル面での明快さとコーディングパワーを両立し、しかもパフォーマンスを犠牲にしないツールが必要でした。**TinyGiants**は、私が日々自分のゲーム開発で使用しているプロフェッショナルグレードのツールへの私のこだわりです。」
—  ***[TinyGiants]** 中国より*
:::

---

## このシステムが存在する理由

:::danger 問題点
従来のUnity開発では、イベントが見えないスパゲッティと化します:

- **隠された依存関係**: 誰がリッスンしている?どこでトリガーされる?見つけ出すのは困難です。
- **実行時の破損**: メソッド名を変更すると、10個のシーンオブジェクトが壊れます。
- **クロスシーンの混乱**: シーンがアンロードされるとイベントが消失し、メモリリークとNull参照があちこちに発生します。
- **可視性の欠如**: 複雑なイベントチェーンは、あなたの頭の中(と古くなったコメント)にしか存在しません。

:::

:::success 解決策
**TinyGiants.GameEventSystem**は、**ビジュアルファースト、型安全**なイベントアーキテクチャを提供します:

✅ **アセットとしてのイベント** - ScriptableObjectベース、GUID保護、リファクタリングに耐える設計  

✅ **ビジュアルフローグラフ** - イベントチェーン、トリガー、条件を一つのウィンドウで可視化  

✅ **ゼロリフレクション実行** - Expression Treeコンパイルによる、C++並みのパフォーマンス  

✅ **デザイナーフレンドリー** - ドラッグ&ドロップバインディング、シンプルなワークフローにコーディングは不要  

✅ **本格的なツール群** - リアルタイムモニタリング、参照検索、コード生成の自動化

:::

---

## コアアーキテクチャ：動作の仕組み

**GameEventSystem** は、イベントロジックを集中管理しつつ、実行の分散化を維持するために設計された「管理-アセット-アクション」アーキテクチャに基づいています。

<div className="img-full-wrapper">

![コアアーキテクチャ図](/img/game-event-system/intro/overview/architecture.png)

</div>

### 🏗️ 基盤：GameEventManager とデータベース
システムの中心となるのは、**イベントデータベース**を管理・維持する **GameEventManager** です。
- **アセットとしてのイベント**：すべてのイベントはデータベースアセット内に保存された `ScriptableObject` です。
- **集中管理**：**GameEventEditorWindow** が主要なコマンドセンターとして機能します。ここから以下の専用ツールにアクセスできます：
    - **Creator**：新しいイベントアセットを迅速に生成します。
    - **Behavior & Finder**：イベントプロパティの設定や、シーンを横断した依存関係の特定を行います。
    - **FlowGraph**：複雑で多段階のイベントシーケンスを視覚的に設計します。
    - **Monitor**：リアルタイムのデバッグとパフォーマンス追跡を行います。

### 🔄 ハイブリッドワークフロー：ビジュアルとコード

このシステムは、技術的な実装とクリエイティブなデザインの間の溝をシームレスに埋めます。

1.  **直接的なコード統合**：プログラマーはスクリプト内で単純な `.Raise()` を呼び出すだけで、どこからでもイベントをトリガーできます。
2.  **ビジュアルなインスペクター結合**：デザイナーは直感的な**ドロップダウンメニュー**を使用して、インスペクター上で直接ロジックをイベントに結合できます。「マジックストリング」や手動のコンポーネント検索は不要です。
3.  **リアルタイム監視**：**Monitor** ウィンドウはイベントアクティビティをライブ表示し、再生モード中にデータフローと実行タイミングを確認するのに役立ちます。

### 💻 完全な API 互換性
デザイナー向けの強力なビジュアルインターフェースを提供していますが、本システムは **API ファースト**で設計されています。
**ビジュアルエディターで利用可能なすべての機能は、Runtime API からもアクセス可能です。** グラフでイベントチェーンを構築する場合でも、C# コードで動的にリスナーを登録・解除する場合でも、システムは同等のパワーとパフォーマンスを提供します。

---

### 💡 なぜこのアーキテクチャなのか？
- **デカップリング（疎結合）**：送信者と受信者は互いを知る必要はありません。イベントアセットさえ知っていれば動作します。
- **可視化**：標準的なイベントによる「見えないスパゲッティコード」が、検索可能なビジュアルデータベースに置き換わります。
- **信頼性**：イベントがアセットであるため、メソッド名の変更やファイルの移動を行っても参照が壊れることはありません。

---

## アーキテクチャの特徴

### 🏗️ 基盤: ScriptableObjectドリブン

文字列ベースやシングルトンイベントシステムとは異なり、**イベントは第一級のアセット**です:
```csharp
// イベントはアセットであり、マジックストリングではありません
[GameEventDropdown] public GameEvent onPlayerDeath;
[GameEventDropdown] public Int32GameEvent onScoreChanged;

void Die() {
    onPlayerDeath.Raise(); // 型安全、アセット参照
}
```

**利点**:

- ✅ **完全な疎結合** - 送信者は受信者を知りません。一度発火すれば、多数に通知。
- ✅ **クロスシーン永続性** - イベントはシーンのロード/アンロードに耐えます。
- ✅ **GUID識別** - ファイル名を変更し、フォルダを再編成しても、参照は決して壊れません。
- ✅ **マルチデータベースサポート** - 大規模チーム向けのモジュラー構成。

<details>
<summary>📖 GUID保護の仕組み</summary>


各イベントは`.meta`ファイルに保存された一意のGUIDを持ちます:
```yaml
# PlayerDeath.asset.meta
guid: a7f3c21e9b4d8f6e2d1a9c8b7e6f5a4d
```

`PlayerDeath`を`OnCharacterDied`に変更しても、UnityはGUIDを通じて参照を維持します。**シーンリンクの破損はありません。**

</details>

---

### 🕸️ ビジュアルフローオーケストレーション

イベントの関係性を理解するためにコードを探し回るのはもうやめましょう。**フローエディター**は、見えないロジックを保守可能なグラフへと変換します:


#### ユースケース

**🎯 トリガー(ファンアウト)**

![alt text](/img/game-event-system/intro/overview/flow-graph-trigger.png)

**⛓️ チェーン(シーケンシャル)**

![alt text](/img/game-event-system/intro/overview/flow-graph-chain.png)

**🔀 ハイブリッドフロー** 

並列+順次ロジックのミックス

![alt text](/img/game-event-system/intro/overview/flow-graph-mix.png)

:::tip ビジュアルの利点

- **グループ整理** - 大規模フロー向けのカラーコード付きグループ
- **リアルタイム検証** - 接続タイプチェック(緑=有効、赤=エラー)
- **アンドゥ/リドゥサポート** - 完全な履歴システム(Ctrl+Z/Y)
- **実行時デバッグ** - プレイモード中にアクティブノードがハイライト

:::

---

### ⚡ 型安全、ゼロリフレクションパフォーマンス

Unityのジェネリックシリアライゼーションは設計上壊れています。私はそれを修正しました。

#### 問題点
```csharp
// ❌ Unityはこれをシリアライズできません
[SerializeField] private GameEvent<PlayerData> onPlayerDataChanged;
```

#### 本システムの解決策
```csharp
// ✅ 自動生成される具象クラス
[GameEventDropdown] public PlayerDataGameEvent onPlayerDataChanged;

// 生成コード(自動):
[Serializable]
public class PlayerDataGameEvent : GameEvent<PlayerData> { }
```

**パフォーマンス上の利点**:

- 🚀 **Expression Treeコンパイル** - 条件は起動時にデリゲートへコンパイル(実行時パースなし)
- 🚀 **リフレクションコストゼロ** - `Invoke()`ではなく、直接メソッド呼び出し
- 🚀 **ネイティブインスペクターサポート** - 完全な`UnityEvent<T>`互換性

<details>
<summary>⚙️ コード生成ワークフロー</summary>


1. **型を選択** - Creatorウィンドウでカスタム型を選択
2. **生成** - 「Generate」をクリックして具象クラスを作成
3. **コンパイル** - Unityが新しいコードを自動コンパイル
4. **作成** - これで、カスタム型のイベントを作成可能に

**所要時間**: 約10秒。**効果**: 生涯の型安全性。

</details>

---

## 機能マトリックス

### ⚓ コアアーキテクチャ

| 機能                    | 説明                                                  |
| :------------------------- | :----------------------------------------------------------- |
| **アセットベースイベント**     | **GUID識別**を持つScriptableObjectアーキテクチャ—参照はリネームやファイル移動に耐えます。 |
| **包括的なジェネリクス** | `GaneEvent<Void>`、`GameEvent<T>`、ソース認識型`GameEvent<TSender, TArgs>`のネイティブサポート。 |
| **マルチデータベースシステム**  | **動的ロード**と**ヘルスチェック**を備えた、複数データベースをサポートするモジュラー構成。 |
| **カテゴリーシステム**        | 大規模イベントライブラリ内での効率的なファジー検索フィルタリングのための文字列ベースの分類。 |
| **自動静的リセット**      | エディタープレイモードでの静的キャッシュの自動クリアによるデータ汚染の防止。 |

### 🧠 高度なロジック&フロー
| 機能                   | 説明                                                  |
| :------------------------ | :----------------------------------------------------------- |
| **Expression Tree**      | **ゼロリフレクション**のロジック評価;条件は実行時に高性能デリゲートへコンパイルされます。 |
| **ビジュアルロジックビルダー**  | コード不要で複雑な**ネストされたAND/ORロジック**と動的プロパティ比較を構築。 |
| **ハイブリッド実行**      | 並列**ファンアウトトリガー**と順次**ブロッキングチェーン**を一つのグラフ内でシームレスにミックス。 |
| **引数トランスフォーマー** | フローノード間で特定のオブジェクトプロパティを引数として動的に抽出・渡す。 |
| **きめ細かいフロー制御** | ノード単位の遅延、**非同期/コルーチン待機**、ループカウント、条件付き実行ゲート。 |

### 🎧 リスニング&バインディング
| 機能                   | 説明                                                  |
| :------------------------ | :----------------------------------------------------------- |
| **ビジュアルバインディング**        | インスペクターでのドラッグ&ドロップ**UnityEvent配線**、ビジュアルステータスマーカーと型安全性付き。 |
| **優先度リスナー**    | **整数ベースのソート**により、重要なシステムが標準UI/Audioリスナーより先に反応することを保証。 |
| **条件付きリスナー** | 組み込みの**Predicateサポート**—コールバックは特定の論理条件が満たされた場合にのみ発火。 |
| **永続リスナー**  | シーン遷移中もアクティブを維持する**クロスシーンリスナー**のネイティブサポート。 |
| **動的実行時API**   | リスナーの登録/登録解除および**タスクハンドル**管理のための完全なプログラマティック制御。 |

### 📊 ツール&デバッグ
| 機能                | 説明                                                  |
| :--------------------- | :----------------------------------------------------------- |
| **ダッシュボード&ウィザード** | **バッチ操作**のためのモダンUIと、迅速なイベント作成のためのファジーマッチングウィザード。 |
| **コード自動化**    | 自動コンパイルパイプライン統合を備えた**三モードCodeGen**(Basic/Custom/Sender)。 |
| **参照ファインダー**   | 特定のイベントアセットを参照しているコンポーネントを正確に特定するシーン全体スキャナー。 |
| **実行時モニター**    | **実行時間(平均/最小/最大)**、リスナー数、**GCアロケーション**のリアルタイムプロファイリング。 |
| **自動化ツリー**    | 複雑なロジックフローをデバッグするための、アクティブなトリガーとチェーン階層のリアルタイムビジュアライザー。 |

------

## パフォーマンス特性

本番ビルドからの実測値:

| シナリオ                        | パフォーマンス | 備考                        |
| ------------------------------- | ----------- | ---------------------------- |
| **イベント発火(リスナー0)**   | ~0.001ms    | 実質的にコストなし               |
| **イベント発火(リスナー10)**  | ~0.02ms     | GCアロケーションなし             |
| **条件評価**        | ~0.003ms    | Expression Treeコンパイル  |
| **フローノード実行**         | ~0.05ms     | コルーチンオーバーヘッド含む  |
| **モニターウィンドウ(イベント100)** | ~0.3ms      | エディターのみ、実行時コストなし |

:::success 本番環境対応
シーン全体で**500以上のイベント**と**10,000以上のリスナー**を持つ出荷タイトルでテスト済み。パフォーマンス低下ゼロ。
:::

------

## 🗺️ ナビゲーションロードマップ

このマップは、システムドキュメント全体の概要を提供します。以下のテーブルを使用して、必要な特定の機能やチュートリアルに素早くジャンプできます。

:::info 推奨学習パス

- 🚀 **最速スタート**: [**Example: Quick Start**](../examples/00-quick-start.md)に直接ジャンプ。
- 🎨 **ビジュアル学習者**: [**ビジュアルワークフロー**](#visual-workflow)と[**フローオーケストレーション**](#flow-orchestration)テーブルに集中。
- 💻 **プログラマー向け詳細**: [**実行時API**](#runtime-api)に直接進む。

:::

### 🏁 1. イントロダクション {#introduction}

イベントアズアセットアーキテクチャの基本セットアップと核となる哲学。

| ページ                                            | 説明                                                  |
| :---------------------------------------------- | :----------------------------------------------------------- |
| [**プロジェクト構造**](./project-structure.md) | ディレクトリレイアウト、フォルダ保護、モジュラー構成の理解。 |
| [**インストール**](./installation.md)           | プラグインの初期化と自動静的リセットパイプラインのセットアップ。 |

### 💎 2. ビジュアルワークフロー {#visual-workflow}

見えないコードを有形のビジュアルダッシュボードへと変換するために設計された管理ツール。

| ページ                                                         | 説明                                                  |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [**システムダッシュボード**](../visual-workflow/game-event-system.md) | アセットベースワークフローとGUID識別システムの概要 |
| [**データベース&フローグラフ**](../visual-workflow/game-event-manager.md) | マルチデータベースおよびマルチフローグラフのセットアップとデータベースヘルスメンテナンス |
| [**ゲームイベント編集**](../visual-workflow/game-event-editor.md) | バッチ編集、検索、カテゴリー分類のためのダッシュボードの使用 |
| [**ゲームイベント作成**](../visual-workflow/game-event-creator.md) | ファジー検索バッチウィザードを使用したイベントアセットの迅速な生成 |
| [**ゲームイベント構成**](../visual-workflow/game-event-behavior.md) | ビジュアルステータスマーカーと型安全性を備えたインスペクターバインディングのマスター |
| [**ゲームイベント発火**](../visual-workflow/game-event-raiser.md) | イベントの呼び出し方法と組み込みGameEventDropdown属性を使用したインスペクターの強化方法を学ぶ |
| [**ゲームイベント検索**](../visual-workflow/game-event-finder.md) | コンポーネントレベルのイベント依存関係を見つけるためのシーンスキャン。 |
| [**ビジュアル条件ツリー**](../visual-workflow/visual-condition-tree.md) | 条件ツリー構成を通じてイベントアクションのロジック実行を制御する方法を学ぶ |

### 🕸️ 3. フローオーケストレーション {#flow-orchestration}

ノードを使用した複雑なマルチステップロジックシーケンスの可視化と構築。

| ページ                                                         | 説明                                                  |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [**ノードエディター**](../flow-graph/game-event-node-editor.md)   | GraphViewキャンバス、グループ、スナップショットベースのアンドゥ/リドゥの管理 |
| [**ノードコネクター**](../flow-graph/game-event-node-connector.md) | ハイブリッド実行モードのルールとリアルタイム接続検証 |
| [**ノードビヘイビア**](../flow-graph/game-event-node-behavior.md) | ノードレベルの遅延、ループ、引数変換ロジックの構成 |
| [**高度なロジックパターン**](../flow-graph/advanced-logic-patterns.md) | ノーコードのネストされたロジックグループと条件付き実行ゲートの構築 |

### 💻 4. スクリプティング&API {#runtime-api}

高性能C#統合とライフサイクル管理のための開発者ガイド。

| ページ                                                         | 説明                                                  |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [**発火&スケジューリング**](../scripting/raising-and-scheduling.md) | プログラマティック発火、遅延実行、タスクハンドル管理 |
| [**リスニング戦略**](../scripting/listening-strategies.md) | 優先度付き、永続、ソース認識(Sender)リスナーの実装 |
| [**プログラマティックフロー**](../scripting/programmatic-flow.md)   | ゼロリフレクションロジックフィルタリングのためのExpression Treeベース述語の使用 |
| [**ベストプラクティス**](../scripting/best-practices.md)         | クリーンな疎結合とデータ汚染防止のためのアーキテクチャのヒント |
| [**APIリファレンス**](../scripting/api-reference.md)           | 全コアクラスと属性の詳細な技術ドキュメント |

### 🛠️ 5. ツール&サポート {#tools-support}

プロフェッショナルな本番環境のための自動化およびモニタリングユーティリティ。

| ページ                                                         | 説明                                                  |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [**CodeGen&クリーンアップ**](../tools/codegen-and-cleanup.md)     | 三モードジェネレーターとコンパイルパイプライン自動化の使用 |
| [**実行時モニター**](../tools/runtime-monitor.md)           | リアルタイムパフォーマンスプロファイリング、詳細ログ、警告システム |
| [**コミュニティ&サポート**](../tools/community-and-support.md) | アップデートへのアクセス、バグ報告、技術サポートの取得 |

### 📚 6. 例 {#examples}

基本から高度なAPI使用まで、すべてのシナリオをカバーする実用的ですぐに使えるシーン。

| ID   | 例ページ                                                 | 主要な学習ポイント                                           |
| :--- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| 00   | [**クイックスタート**](../examples/00-quick-start.md)             | イベントの作成、発火、バインディングのための最小限のワークフロー |
| 01   | [**Voidイベント**](../examples/01-void-event.md)               | 「レベル開始」のようなグローバルトリガーのためのパラメータなしシグナルの使用 |
| 02   | [**基本型イベント**](../examples/02-basic-types-event.md) | イベントを通じてプリミティブデータ(int、float、string)を渡す   |
| 03   | [**カスタム型イベント**](../examples/03-custom-type-event.md) | シリアライズされたカスタムデータクラスと構造体のためのCodeGenの活用 |
| 04   | [**カスタムSenderイベント**](../examples/04-custom-sender-event.md) | どのエンティティがシグナルを発火したかを識別するソース認識イベントの使用 |
| 05   | [**優先度イベント**](../examples/05-priority-event.md)       | 複数のリスナーの実行順序を正確に制御 |
| 06   | [**条件付きイベント**](../examples/06-conditional-event.md) | 条件が満たされた場合にのみコールバックを実行するための述語の使用 |
| 07   | [**遅延イベント**](../examples/07-delayed-event.md)         | タイミングロジックの管理とキャンセルのためのタスクハンドルの使用 |
| 08   | [**繰り返しイベント**](../examples/08-repeating-event.md)     | 繰り返しパルスシグナルと自動ロジックループの作成   |
| 09   | [**永続イベント**](../examples/09-persistent-event.md)   | シーン遷移中のイベント処理(DontDestroyOnLoad) |
| 10   | [**トリガーイベント**](../examples/10-trigger-event.md)         | UnityのPhysicsシステムとGame Eventアセットのブリッジング       |
| 11   | [**チェーンイベント**](../examples/11-chain-event.md)             | フローオーケストレーショングラフを使用したビジュアルシーケンシャルロジックの構築 |
| 12   | [**マルチデータベース**](../examples/12-multi-database.md)       | モジュラープロジェクト構成のための異なるアセットへのイベント分離 |
| 13   | [**実行時API**](../examples/13-runtime-api.md)             | C#スクリプトを介してリスナーを動的に登録/登録解除 |
| 14   | [**実行時モニター**](../examples/14-runtime-monitor.md)     | 実行タイミングとGCアロケーションをデバッグするためのプロファイリングツールの使用 |

:::tip ナビゲーションのヒント
実践的な開始には、まず**Example 00(クイックスタート)**に従い、その後**ビジュアルワークフロー**セクションを探索して、エディターツールがどのように開発を効率化できるかを確認することをお勧めします。
:::